# 람다와 함수형 인터페이스
--- ---
## Learning Objectives
    람다 표현식 : 익명 클래스를 람다 표현식으로 변경 과정
    람담 표현식 주요 문법
    함수형 인터페이스 : 함수형 인터페이스가 무엇인지, 어떻게 사용하고 람다 표현식과 어떻게 연결.
    메서드 참조 : 메서드 참조 방법과 규칙, 그리고 사용시 장점.
<br>

--- ---
<br>

### 람다 표현식이 필요한 이유.
    프레임워크와 라이브러리가 추가되면서 유연성과 다양성을 확보하기 위해 인터페이스 기반으로 개발을 많이 한다.
    이 때문에 명세(IFS)와 구현(Class)를 분리하고 결과적으로 많은 클래스 파일이 생성된다.
    경우에 따라서 구현체는 제공하지 않고 인터페이스만 제공하는 경우도 있다.
    이에 대응하기 위해 별도로 구현된 클래스를 만들거나 중첩 클래스 또는 익명 클래스 형태로 구현된다.
    하지만 익명 클래스를 많이 만들면 이전에 배웠던 것처럼 로직의 구혀보다 그것을 담기 위해 코드를 더 많이 
    작성하게 되고 중복 코드가 역시나 많아지는 문제점이 생기고 코드의 양이 비대해져 가독성이 떨어진다.
    자바는 이런 비효율적인 구조를 개선하기 위해 템플릿을 내놓았지만 익명 클래스의 사용을 줄이지 못했다.
    람다 표현식이야 말로 익명 클래스를 대체하는데 매우 유용하다.
    ex) comparable ,sort(new Compator<Object>(){ ... }),스프링의 jdbcTemplates 
        - 람다 사용 sort
            Collections.sort((Object o1,Object o2)-> o1.기준-o2.기준));
<br>
<br>

#### 람다식을 통한 장점.

- 이름 없는 함수를 선언.(메서드는 반드시 특정 클래스 또는 인터페이스 안에 포함되어야 하고 메서드의 이름이 있어야 하지만,
    람다는 이러한 제약에 벗어나서 제약 조건이 완화되어 유연성이 생긴다.
- 소스코드의 분량을 줄일수 있다.
- 코드를 파라미터로 전달할 수 있다.(제약 조건을 외부에서 정의하도록 한다.)


### 람다식 이해하기( 변환 과정을 통해 람다 표현식 이해. )
- 람다 표현식<br><br>
    - 익명 클래스를 단순화하여 그 표현식을 메서드의 인수로 전달하거나 또는 인터페이스 객체를 생성할 수 있는 기능을 제공.
      <br><br>
    - 메서드의 구성요소 4가지 파악하기
        1. 메서드의 이름
        2. 파리미터 목록
        3. 메서드 본문
        4. 메서드 리턴타입
        중요도 :  목록,본문 -> 리턴타입 -> 이름
        ex ) Thread 제거 순위 인터페이스 이름 -> 리턴타입과 메서드명 -> 파라미터 대체 (->)
           <br><br>
    - 익명 클래스 기반 코드를 람다로 변경하는 절차
        - 메서드 정의
        - 인터페이스 이름 제거
        - 파리미터 목록과 구현한 바디 영역을 제외하고 리턴타입, 메서드명 삭제
        - '->' 이용 문장 완성
          <br><br>
    - 람다 표현식 3가지 구성
        - 파라미터 목록
        - 화살표
        - 메서드 본문.
        - ※ 화살표 왼쪽은 파라미터 목록 , 오른쪽은 구현 영역.
          <br><br>
- 람다 특징
    - 이름이 없다.
    - 종속되지 않는다.
    - **값(혹은 객체)의 특징을 갖는다.**
    - 간단하다
    - 새로운 것이 아니다.
      <br>
      <br>
      <br>
### 형식 추론 
    데이터 타입 또한 생략하여 작성할 수 있지만 아직은 익숙치 않으므로 알고만 있는다. (생략은 지양한다)
<br>

### 람다 표현식과 변수
    - 로컬 변수도 참조 가능하다.
    - 주의 점 : 람다 표현식에서 외부 변수를 참조하기 위해 반드시 final 이거나 유사 조건이여야 한다.
            왜냐하면 값이 변경될 가능성이 없다면 컴파일러는 final 변수와 동일하게 취급하며, 컴파일 오류에서 걸러 내지 못하기 떄문이다.

### 함수형 인터페이스 기본
- 인터페이스는 통상 여러 개의 메서드를 포함. 그에 비해 람다는 이름없고 파리미터와 리턴타입으로 식별하는데 어떻게 자바 컴파일러가 이를 인식하고 인터페이스의 구현체로 컴파일 할 수 있을까?
  <br><br>
- 람다 표현식을 쓸 수 있는 인터페이스는 오직 public 메서드 하나만 가지고 있는 인터페이스여야 한다.
  <br><br>
- 그것을 함수형 인터페이스라고 부른다.
  <br><br>
- 함수형 인터페이스에서 제공하는 단 하나의 추상 메서드를 함수형 메서드라고 부른다.
  <br><br>
    - 수만은 API를 만드는 입장에서 계속 함수형 인터페이스를 만들면 번거로움이 발생한다. 
    - 함수형 인터페이스 패키지 제공 . @FunctionalInterface 
    - EX ) Consumer, Function, Predicate, Suplier
    - |      IFS      	|       method      	| Content 	|
      |:-------------:	|:-----------------:	|:-------:	|
      |  Consumer<T>  	|  void accept(T t) 	| 파라미터 전달 하여 처리 후 결과를 리턴 받을 필요가 없을 떄 사용.         	|
      | Function<T,R> 	|    R apply(T t)   	| 전달할 파리미터를 다른 값으로 변환해서 리턴할 때, 주로 값을 변경 또는 매핑 할 떄 사용        	|
      |  Predicate<T> 	| boolean test(T t) 	| 전달받은 값에 대한 boolean 타입, 주로 데이터 필터링하거나 조건에 맞는 여부 판단.        	|
      |   Suplier<T>  	|      T get()      	| 파라미터 없이 리턴 값만 있는 경우. |
    
### 함수형 인터페이스 응용
#### 기본형 데이터를 위한 인터페이스
    Boxing : 기본형 데이터를 객채형으로 변환.
    UnBoxing : 객체형을 기본형 데이터로 변환.
    ※ 개발자가 직접 코딩하는 과정을 없애 주므로 오토 라는 수식어가 앞에 붙는다. 
       하지만 가상 머신 입장에서는 비용이 많이 드는 작업으로 SW에 악영향을 주는데 유념해야 한다.
       함수형 인터페이스 또한 오토 언박싱 ,박싱이 발생한다.
       함수형 인터페이스의 함수형 메서드에는 리턴 타입이 반드시 객체형이기 때문에 대량 데이터 처리시 성능에 약 영향을 미칠 수 있다.
**기본형 인터페이스 사용 권장.** Consumer,Function,Suplier,Predicate
    
##### Operator 
    - Functional IFS 서브 인터페이스로 이름 그대로 연산이 목적인 IFS이다.
    - Unary 와 Binary 의 차이는 한개의 연산, 두개의 연산의 차이.

### 메서드 참조
    함수를 메서드의 파라미터로 전달하는 것.

- 메서드 참조의 장점.
    - 람다 표현식과는 달리 코드를 여러 곳에서 재사용 할 수 있고 자바의 기본 제공 메서드 뿐만 아니라 직접 개발한 메스드도 사용 가능하다.
    - 람다 표현식의 축약(익명 클래스 대체), 코드의 가독성 증진.
    - 함수형 IFS 와 연관 되어 있지만 람다 표현식을 대체하기 위한 것은 아니며, 상호 보완적인 관계 이다.
      <br><br>
- 메소드 참조 정의 방법. (::)
    -  className :: methodName
    -  Object Variable :: methodName
    <br>
    <br>

- 메소드 참조 세가지 구성
    - 정적 메서드 참조 : static 으로 정의한 메서드 참조.
    - 비 한정적 메서드 참조 : public 또는 protected로 정의한 메서드 참조.
    - 한정적 메서드 참조 : 외부에서 선언된 객체 메서드 호출, 객체를 직정 생성 메서드 참조.
    
**※  메서드 참조가 실제로 메서드가 실행된 결과를 리턴한다고 생각하는 것인데, 코드 자체를 전달하는 것이 실행 결과를 전달하는 것이 아니다.**
    
- 정적 메서드
  - static 메서드 호출 때 (객체의 생성 없이 호출)
  <br>
  <br>
- 비한정적 메서드 참조
    - 비 한정적이라는 표현은 작성하는 구문 자체가 특정한 객체를 참조하기 위한 변수를 지정하지 않는다 라는 의미.
    ex ) String::toUpperCase 반드시 String 클래스가 객체화 되어야만 실행 가능하다.
    -  정렬을 하는 상황에서 연속된 데이터 중 두 씩 데이터를 뽑아 크기를 구할 때는 람다 표혀식을 사용하여 이해하기 편하다.
    ex ) list.stream().sorted(String a,String b)-> a.compareTo(b);
    - 만약 메서드 참조형태로 바뀌면 코드 해석이 난해 한 경우가 발생.
    ex) list.stream().sorted(String::compareTo) // 짧게 작성하지만 코드 해석이 어렵다. , 생략이 너무 많다.
      <br>
      <br>
- 한정적 메서드 참조
    - 객체 생성후 메서드 호출
    
```javascript
        // 정적 메서드 참조
        System.out.println("===");
        list.stream().forEach(MethodRefEx::exeMethod);
        System.out.println("===");
        // 한정적 메서드 참조
        list.stream().forEach(MethodRefEx.of()::toUpper);
        System.out.println("===");
        // 비한정적 메서드 참조.
        list.stream().map(String::toUpperCase).forEach(System.out::println);
```
<p style="color: cornflowerblue">
한정적 메서드 참조는 외부에서 정의한 객체의 메서드를 참조할 때 사용하며,
비한정적 메서드 참조는 람다 표현식 내부에서 생성한 객체의 메서드를 사용한다는 점.
</p>

### 생성자 참조


**클래스명::nex**

```javascript
        // 람다 표현식
        list.stream().map((String name)-> new ConstructorRefEx(name)).forEach( (ConstructorRefEx constructorRefEx) -> System.out.println(constructorRefEx));

        // 생성자 참조로 변환
        list.stream().map(ConstructorRefEx::new).forEach( (ConstructorRefEx constructorRefEx) -> System.out.println(constructorRefEx));

        // 생성자 참조, 메서드 참조로 변환
        list.stream().map(ConstructorRefEx::new).forEach(System.out::println);
```
    

    
    
